<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Descomplicando ArgoCD</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/style.css">
        <link rel="stylesheet" href="../theme/css/mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introdução</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../BOOKSUMMARY.html">Sumário</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Capítulos</li><li class="chapter-item expanded "><a href="../day-1/index.html" class="active"><strong aria-hidden="true">1.</strong> Dia 1</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Descomplicando ArgoCD</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/badtuxx/DescomplicandoArgoCD" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/badtuxx/DescomplicandoArgoCD/edit/main/pt/src/day-1/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="descomplicando-argocd---day-1"><a class="header" href="#descomplicando-argocd---day-1">Descomplicando ArgoCD - DAY-1</a></h1>
<h2 id="o-que-vamos-aprender-no-day-1"><a class="header" href="#o-que-vamos-aprender-no-day-1">O que vamos aprender no Day-1?</a></h2>
<p>Durante o day-1 iremos aprender o que é o ArgoCD, vamos entender o que é o GitOps e o que é estado desejado, vamos entender o que é um continuous delivery e como o ArgoCD pode nos ajudar a entregar nossas aplicações no Kubernetes de forma contínua e segura.</p>
<p>Vamos ainda ver como instalar o nosso ArgoCD no Kubernetes como um operador, e também iremos instalar o ArgoCD CLI, que é a ferramenta que vamos utilizar para gerenciar as nossas aplicações no ArgoCD.</p>
<p>Vamos adicionar o nosso cluster e criar a nossa primeira aplicação no ArgoCD, para que seja possível o deploy em nosso cluster.</p>
<p>Enfim, muita coisa interessante para aprender no day-1, e para isso, vamos precisar de alguns pré-requisitos.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Ter um cluster Kubernetes rodando</li>
<li><input disabled="" type="checkbox"/>
Ter o kubectl instalado</li>
<li><input disabled="" type="checkbox"/>
Ter força de vontade para aprender</li>
</ul>
<p>Preencheu os pré-requisitos? Então vamos lá!</p>
<p> </p>
<h2 id="conteúdo-do-day-1"><a class="header" href="#conteúdo-do-day-1">Conteúdo do Day-1</a></h2>
<ul>
<li><a href="#descomplicando-argocd---day-1">Descomplicando ArgoCD - DAY-1</a>
<ul>
<li><a href="#o-que-vamos-aprender-no-day-1">O que vamos aprender no Day-1?</a></li>
<li><a href="#conte%C3%BAdo-do-day-1">Conteúdo do Day-1</a></li>
<li><a href="#o-que-%C3%A9-o-argocd">O que é o ArgoCD?</a></li>
<li><a href="#o-que-%C3%A9-gitops">O que é GitOps?</a></li>
<li><a href="#pr%C3%A9-requisitos">Pré-requisitos</a></li>
<li><a href="#instalando-o-argocd">Instalando o ArgoCD</a>
<ul>
<li><a href="#instalando-o-argocd-como-um-operador-no-kubernetes">Instalando o ArgoCD como um operador no Kubernetes</a></li>
</ul>
</li>
<li><a href="#instalando-o-argocd-cli">Instalando o ArgoCD CLI</a></li>
<li><a href="#autenticando-no-argocd">Autenticando no ArgoCD</a></li>
<li><a href="#criando-a-aplica%C3%A7%C3%A3o-no-argocd">Criando a aplicação no ArgoCD</a>
<ul>
<li><a href="#criando-a-nossa-app-exemplo">Criando a nossa app exemplo</a></li>
<li><a href="#criando-a-app-no-argocd-usando-o-argocd-cli">Criando a app no ArgoCD usando o ArgoCD CLI</a></li>
<li><a href="#primeiros-passos-com-o-argocd-e-nossa-app">Primeiros passos com o ArgoCD e nossa app</a></li>
</ul>
</li>
<li><a href="#final-day-1">Final Day-1</a></li>
</ul>
</li>
</ul>
<p> </p>
<h2 id="o-que-é-o-argocd"><a class="header" href="#o-que-é-o-argocd">O que é o ArgoCD?</a></h2>
<p>O ArgoCD é uma poderoso ferramenta quando você pensa em GitOps ou Continous Delivery. O ArgoCD é um projeto open source, criado pela <a href="https://argoproj.github.io/argo/">Argo</a>, que tem como objetivo facilitar a implantação e gerenciamento de aplicações em Kubernetes.</p>
<p>O ArgoCD foi escrito em Go e utiliza o <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Kubernetes Operator Pattern</a> para gerenciar os recursos do Kubernetes.</p>
<p>Dito isso, fica claro que quando você instala o ArgoCD, você está instalando um operador do Kubernetes, que está extendendo o Kubernetes, adicionando novos <code>Custom Resources</code> e novos <code>Controllers</code> para gerenciar esses <code>Custom Resources</code>.</p>
<p>Vamos ver isso com mais detalhes mais pra frente, mas por agora saiba que o ArgoCD vai mudar a forma como você pensa e trabalha com Kubernetes.</p>
<p>Talvez esse seja somente o seu primeiro passo para o mundo do GitOps e do Continous Delivery, sim, entregas contínuas.</p>
<p>Você e sua equipe terá que se adaptar e criar maturidade para trabalhar com entregas contínuas, pois entregar é a tarefa mais fácil, o difícil é entregar com qualidade e com segurança de que não vai quebrar nada, que foi testado e que não vai afetar o negócio.</p>
<p>Um forte característica do ArgoCD é a sua separação de responsabilidades quando estamos falando de CI/CD. Ele não se preocupa em ser um solução completa para a sua esteira de CI/CD, ele se preocupa em ser uma ferramenta que vai gerenciar as entregas contínuas no Kubernetes, ele se preocupa com a parte CD, e não com a parte CI.</p>
<p>Acho que essa é uma boa apresentação do ArgoCD, e nem vou vou precisar falar que ele é peça fundamental nas melhores engenharías de software do mundo.</p>
<p>Está preparado para mais essa viajem com o objetivo de descomplicar mais um assunto, o ArgoCD?</p>
<p>#VAIIII</p>
<h2 id="o-que-é-gitops"><a class="header" href="#o-que-é-gitops">O que é GitOps?</a></h2>
<p>Esse livro não tem como objetivo descomplicar o GitOps. Nesse livro o nosso objetivo é descomplicar uma das etapas fundamentais do GitOps, que é a utilização do ArgoCD para gerenciar as entregas contínuas no Kubernetes.</p>
<p>O GitOps é um conceito que foi criado pela <a href="https://www.weave.works/">Weaveworks</a>, e que tem como objetivo facilitar a entrega de aplicações no Kubernetes, utilizando o Git como fonte de verdade. O Git é a fonte de verdade, e o Git é o único lugar onde você vai encontrar a verdade sobre o estado da sua aplicação.</p>
<p>Se lá é a fonte da verdade, vale a pena falar que quando estamos falando de GitOps, estamos falando sobre modo declarativo de gerenciar as aplicações no Kubernetes. Quando falamos em declarativo, estamos falando que o estado que das suas aplicação no Kubernetes, é o mesmo que está no Git, que é o mesmo que você deseja que esteja no Kubernetes.</p>
<p>Confuso? Calma, eu te explico.</p>
<p>Vamos imaginar que você tenha o seguinte arquivo no Git:</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # versão da API
kind: Deployment # tipo de recurso, no caso, um Deployment
metadata: # metadados do recurso 
  name: nginx-server # nome do recurso
spec: # especificação do recurso
  selector: # seletor para identificar os pods que serão gerenciados pelo deployment
    matchLabels: # labels que identificam os pods que serão gerenciados pelo deployment
      app: nginx # label que identifica o app que será gerenciado pelo deployment
  replicas: 2 # quantidade de réplicas do deployment
  template: # template do deployment
    metadata: # metadados do template
      labels: # labels do template
        app: nginx # label que identifica o app
      annotations: # annotations do template
        prometheus.io/scrape: 'true' # habilita o scraping do Prometheus
        prometheus.io/port: '9113' # porta do target
    spec: # especificação do template
      containers: # containers do template 
        - name: nginx # nome do container
          image: nginx # imagem do container do Nginx
          ports: # portas do container
            - containerPort: 80 # porta do container
              name: http # nome da porta
          volumeMounts: # volumes que serão montados no container
            - name: nginx-config # nome do volume
              mountPath: /etc/nginx/conf.d/default.conf # caminho de montagem do volume
              subPath: nginx.conf # subpath do volume
        - name: nginx-exporter # nome do container que será o exporter
          image: 'nginx/nginx-prometheus-exporter:0.11.0' # imagem do container do exporter
          args: # argumentos do container
            - '-nginx.scrape-uri=http://localhost/metrics' # argumento para definir a URI de scraping
          resources: # recursos do container
            limits: # limites de recursos
              memory: 128Mi # limite de memória
              cpu: 0.3 # limite de CPU
          ports: # portas do container
            - containerPort: 9113 # porta do container que será exposta
              name: metrics # nome da porta
      volumes: # volumes do template
        - configMap: # configmap do volume, nós iremos criar esse volume através de um configmap
            defaultMode: 420 # modo padrão do volume
            name: nginx-config # nome do configmap
          name: nginx-config # nome do volume
</code></pre>
<p> </p>
<p>Vamos dar o nome para esse arquivo de <code>nginx-deployment.yaml</code>.</p>
<p>Esse arquivo é somente um manifesto do Kubernetes, onde estamos especificando um <code>Deployment</code> do Nginx, com 2 réplicas, onde o Nginx está exposto na porta 80, e o Prometheus está fazendo o scraping da porta 9113.</p>
<p>Perceba, nesse arquivo estamos falando para o Kubernetes, que queremos que o Nginx esteja rodando com 2 réplicas, e que o Prometheus está fazendo o scraping da porta 9113, estamos declarando o estado desejado da nossa aplicação.</p>
<p>Para aplicar esse arquivo no Kubernetes, basta executar o seguinte comando:</p>
<pre><code class="language-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<p>Vamos imaginar que por algum motivo precisamos mudar a quantidade de réplicas do Nginx para 3. Nós desejamos declarar o estado da nossa aplicação para 3 réplicas. </p>
<p>Para isso, basta declarar, alterar a quantidade de réplicas do Nginx para 3 no arquivo <code>nginx-deployment.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # versão da API
kind: Deployment # tipo de recurso, no caso, um Deployment
metadata: # metadados do recurso 
  name: nginx-server # nome do recurso
spec: # especificação do recurso
  selector: # seletor para identificar os pods que serão gerenciados pelo deployment
    matchLabels: # labels que identificam os pods que serão gerenciados pelo deployment
      app: nginx # label que identifica o app que será gerenciado pelo deployment
  replicas: 3 # quantidade de réplicas do deployment
  template: # template do deployment
    metadata: # metadados do template
      labels: # labels do template
        app: nginx # label que identifica o app
      annotations: # annotations do template
        prometheus.io/scrape: 'true' # habilita o scraping do Prometheus
        prometheus.io/port: '9113' # porta do target
    spec: # especificação do template
      containers: # containers do template 
        - name: nginx # nome do container
          image: nginx # imagem do container do Nginx
          ports: # portas do container
            - containerPort: 80 # porta do container
              name: http # nome da porta
          volumeMounts: # volumes que serão montados no container
            - name: nginx-config # nome do volume
              mountPath: /etc/nginx/conf.d/default.conf # caminho de montagem do volume
              subPath: nginx.conf # subpath do volume
        - name: nginx-exporter # nome do container que será o exporter
          image: 'nginx/nginx-prometheus-exporter:0.11.0' # imagem do container do exporter
          args: # argumentos do container
            - '-nginx.scrape-uri=http://localhost/metrics' # argumento para definir a URI de scraping
          resources: # recursos do container
            limits: # limites de recursos
              memory: 128Mi # limite de memória
              cpu: 0.3 # limite de CPU
          ports: # portas do container
            - containerPort: 9113 # porta do container que será exposta
              name: metrics # nome da porta
      volumes: # volumes do template
        - configMap: # configmap do volume, nós iremos criar esse volume através de um configmap
            defaultMode: 420 # modo padrão do volume
            name: nginx-config # nome do configmap
          name: nginx-config # nome do volume
</code></pre>
<p> </p>
<p>Para que sua vonta seja aplicada, basta executar o seguinte comando:</p>
<pre><code class="language-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<p>Pronto, agora o Kubernetes sabe que você deseja que o Nginx esteja rodando com 3 réplicas e assim o fez.</p>
<p>Isso é o que chamamos de <strong>estado desejado</strong>, estado que declaramos para o Kubernetes, e o Kubernetes mudou o estado atual para o estado desejado.</p>
<p>Acredito que agora você tenha entendido um conceito muito importante do Kubernetes e no GitOps, que é o <strong>estado desejado</strong>.</p>
<p>Se é importante para o GitOps, é importante para o ArgoCD, e é por isso que o ArgoCD trabalha com o conceito de <strong>estado desejado</strong>.</p>
<p>Eu não vou entrar em muito detalhes aqui sobre o que é o GitOps, pois teremos um repo só para isso. Mas basicamente o GitOps é uma metodologia de gerenciamento de configurações, onde o Git é a única fonte de verdade, e o Git é o único responsável por declarar o estado desejado da aplicação.</p>
<p> </p>
<h2 id="pré-requisitos"><a class="header" href="#pré-requisitos">Pré-requisitos</a></h2>
<p>Para que possamos continuar daqui para frente, precisamos ter o seguinte instalado:</p>
<ul>
<li>Um cluster Kubernetes</li>
<li>kubectl instalado</li>
<li>E muita vontade de aprender</li>
</ul>
<h2 id="instalando-o-argocd"><a class="header" href="#instalando-o-argocd">Instalando o ArgoCD</a></h2>
<p>Primeira coisa, como eu falei anteriormente, o ArgoCD é escrito em GO, o que nos ajuda demais no processo de instalação.</p>
<p>Aqui precisamos dividir essa instalação em duas partes, a instalação do ArgoCD como um operador no Kubernetes, e a instalação do ArgoCD como CLI, para que você possa utilizar o ArgoCD no seu dia a dia.</p>
<p>Ele possui ainda uma interface gráfica, que é o ArgoCD UI, mas não iremos abordar por enquanto, eu quero que a gente fique antes muito confortável com o ArgoCD CLI, que é o que iremos utilizar no nosso dia a dia.</p>
<p>No começo ainda vamos utilizar somente o CLI, mas muito em breve vamos utilizar manifestos para definir as nossa aplicações dentro do ArgoCD.</p>
<p> </p>
<h3 id="instalando-o-argocd-como-um-operador-no-kubernetes"><a class="header" href="#instalando-o-argocd-como-um-operador-no-kubernetes">Instalando o ArgoCD como um operador no Kubernetes</a></h3>
<p>Para instalar o ArgoCD como um operador no Kubernetes, antes precisamos criar uma namespace chamada <code>argocd</code>, e para isso basta executar o seguinte comando:</p>
<pre><code class="language-bash">kubectl create namespace argocd
</code></pre>
<p> </p>
<p>A saída desse comando será algo parecido com isso:</p>
<pre><code class="language-bash">namespace/argocd created
</code></pre>
<p>Agora vamos instalar o ArgoCD como um operador no Kubernetes:</p>
<pre><code class="language-bash">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
</code></pre>
<p> </p>
<p>A saída desse comando será algo parecido com isso:</p>
<pre><code class="language-bash">namespace/argocd created
customresourcedefinition.apiextensions.k8s.io/applications.argoproj.io created
customresourcedefinition.apiextensions.k8s.io/applicationsets.argoproj.io created
customresourcedefinition.apiextensions.k8s.io/appprojects.argoproj.io created
serviceaccount/argocd-application-controller created
serviceaccount/argocd-applicationset-controller created
serviceaccount/argocd-dex-server created
serviceaccount/argocd-notifications-controller created
serviceaccount/argocd-redis created
serviceaccount/argocd-repo-server created
serviceaccount/argocd-server created
role.rbac.authorization.k8s.io/argocd-application-controller created
role.rbac.authorization.k8s.io/argocd-applicationset-controller created
role.rbac.authorization.k8s.io/argocd-dex-server created
role.rbac.authorization.k8s.io/argocd-notifications-controller created
role.rbac.authorization.k8s.io/argocd-server created
clusterrole.rbac.authorization.k8s.io/argocd-application-controller created
clusterrole.rbac.authorization.k8s.io/argocd-server created
rolebinding.rbac.authorization.k8s.io/argocd-application-controller created
rolebinding.rbac.authorization.k8s.io/argocd-applicationset-controller created
rolebinding.rbac.authorization.k8s.io/argocd-dex-server created
rolebinding.rbac.authorization.k8s.io/argocd-notifications-controller created
rolebinding.rbac.authorization.k8s.io/argocd-redis created
rolebinding.rbac.authorization.k8s.io/argocd-server created
clusterrolebinding.rbac.authorization.k8s.io/argocd-application-controller created
clusterrolebinding.rbac.authorization.k8s.io/argocd-server created
configmap/argocd-cm created
configmap/argocd-cmd-params-cm created
configmap/argocd-gpg-keys-cm created
configmap/argocd-notifications-cm created
configmap/argocd-rbac-cm created
configmap/argocd-ssh-known-hosts-cm created
configmap/argocd-tls-certs-cm created
secret/argocd-notifications-secret created
secret/argocd-secret created
service/argocd-applicationset-controller created
service/argocd-dex-server created
service/argocd-metrics created
service/argocd-notifications-controller-metrics created
service/argocd-redis created
service/argocd-repo-server created
service/argocd-server created
service/argocd-server-metrics created
deployment.apps/argocd-applicationset-controller created
deployment.apps/argocd-dex-server created
deployment.apps/argocd-notifications-controller created
deployment.apps/argocd-redis created
deployment.apps/argocd-repo-server created
deployment.apps/argocd-server created
statefulset.apps/argocd-application-controller created
networkpolicy.networking.k8s.io/argocd-application-controller-network-policy created
networkpolicy.networking.k8s.io/argocd-applicationset-controller-network-policy created
networkpolicy.networking.k8s.io/argocd-dex-server-network-policy created
networkpolicy.networking.k8s.io/argocd-notifications-controller-network-policy created
networkpolicy.networking.k8s.io/argocd-redis-network-policy created
networkpolicy.networking.k8s.io/argocd-repo-server-network-policy created
networkpolicy.networking.k8s.io/argocd-server-network-policy created
</code></pre>
<p> </p>
<p>Como você pode ver, com o comando acima configuramos o ArgoCD através da criação de vários objetos no Kubernetes, como por exemplo, um <code>deployment</code> para o <code>argocd-server</code>, um <code>service</code> para o <code>argocd-server</code>, um <code>configmap</code> para o <code>argocd-cm</code>, e por aí vai.</p>
<p>Caso você queira conhecer mais sobre o projeto, vá até o <a href="https://github.com/argoproj/argo-cd">repositório oficial</a></p>
<p> </p>
<p>Vamos ver se os pods do ArgoCD foram criados com sucesso:</p>
<pre><code class="language-bash">kubectl get pods -n argocd
</code></pre>
<p> </p>
<p>A saída desse comando será algo parecido com isso:</p>
<pre><code class="language-bash">NAME                                                READY   STATUS    RESTARTS   AGE
argocd-application-controller-0                     1/1     Running   0          115s
argocd-applicationset-controller-5f67f4c987-vdtpr   1/1     Running   0          117s
argocd-dex-server-5859d89dcc-c69fx                  1/1     Running   0          117s
argocd-notifications-controller-75c986587-7jznn     1/1     Running   0          116s
argocd-redis-74c8c9c8c6-mzdlv                       1/1     Running   0          116s
argocd-repo-server-76f77874d7-8qscp                 1/1     Running   0          116s
argocd-server-64d5654c48-tkv65                      1/1     Running   0          116s
</code></pre>
<p> </p>
<p>Onde temos os seguintes pods:</p>
<ul>
<li>argocd-application-controller-0 - Responsável por gerenciar os recursos do Kubernetes</li>
<li>argocd-applicationset-controller-5f67f4c987-vdtpr - Controller responsável por gerenciar os <code>ApplicationSets</code></li>
<li>argocd-dex-server-5859d89dcc-c69fx - Responsável por gerenciar a autenticação</li>
<li>argocd-notifications-controller-75c986587-7jznn - Responsável por gerenciar as notificações, como por exemplo, quando um <code>Application</code> é atualizado</li>
<li>argocd-redis-74c8c9c8c6-mzdlv - Responsável por armazenar os dados do ArgoCD</li>
<li>argocd-repo-server-76f77874d7-8qscp - Responsável por gerenciar os repositórios</li>
<li>argocd-server-64d5654c48-tkv65 - Responsável por expor a interface gráfica do ArgoCD</li>
</ul>
<p> </p>
<p>Pronto, apresentados. No decorrer do livro iremos falar mais sobre cada um desses componentes, mas por agora é o que você precisa saber.</p>
<p>Todos os nossos podes estão com o status <code>Running</code>, o que significa que eles estão funcionando corretamente.</p>
<p> </p>
<h2 id="instalando-o-argocd-cli"><a class="header" href="#instalando-o-argocd-cli">Instalando o ArgoCD CLI</a></h2>
<p>Como eu falei, o ArgoCD possui uma interface gráfica, mas também é possível interagir com ele através de comandos. Para isso, precisamos instalar o <code>argocd</code> CLI.</p>
<p>Nós vamos focar a primeira parte desse livro no CLI, para que você consiga entender como funciona o ArgoCD por baixo dos panos, e depois sim, se delicie com a interface gráfica.</p>
<p>Para instalar o <code>argocd</code> CLI no Linux, basta executar o seguinte comando:</p>
<pre><code class="language-bash">curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64

sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

rm argocd-linux-amd64
</code></pre>
<p> </p>
<p>Com o comando acima fizemos o download do binário do <code>argocd</code> CLI, e o instalamos no diretório <code>/usr/local/bin/argocd</code>, para fazer a instalação utilizamos o comando <code>install</code> do Linux, que é um comando que faz a instalação de arquivos e diretórios. Passamos os parâmetros <code>-m 555</code> para definir as permissões do arquivo, e o nome do arquivo que queremos instalar.</p>
<p>Pronto! O nosso <code>argocd</code> CLI está instalado.</p>
<p>Vamos ver se ele está funcionando corretamente:</p>
<pre><code class="language-bash">argocd version
</code></pre>
<p> </p>
<p>Qual a versão do <code>argocd</code> CLI que você está utilizando? Comenta lá no Twitter e me marca para eu saber como está sendo essa sua abordagem com o ArgoCD. @badtux_, esse é o meu arroba lá no Twitter.</p>
<p> </p>
<h2 id="autenticando-no-argocd"><a class="header" href="#autenticando-no-argocd">Autenticando no ArgoCD</a></h2>
<p>Agora que já temos o ArgoCD instalado, tanto o CLI quanto o operador, precisamos fazer a autenticação no ArgoCD para que possamos dar os primeiros passos.</p>
<p>Antes de mais nada, precisamos saber qual o endereço do ArgoCD. Para isso, vamos executar o seguinte comando:</p>
<pre><code class="language-bash">kubectl get svc -n argocd
</code></pre>
<p> </p>
<p>A saída desse comando será algo parecido com isso:</p>
<pre><code class="language-bash">NAME                                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE
argocd-applicationset-controller          ClusterIP   10.100.164.34    &lt;none&gt;        7000/TCP,8080/TCP            12m
argocd-dex-server                         ClusterIP   10.100.14.112    &lt;none&gt;        5556/TCP,5557/TCP,5558/TCP   12m
argocd-metrics                            ClusterIP   10.100.146.115   &lt;none&gt;        8082/TCP                     12m
argocd-notifications-controller-metrics   ClusterIP   10.100.81.159    &lt;none&gt;        9001/TCP                     12m
argocd-redis                              ClusterIP   10.100.174.178   &lt;none&gt;        6379/TCP                     12m
argocd-repo-server                        ClusterIP   10.100.148.141   &lt;none&gt;        8081/TCP,8084/TCP            12m
argocd-server                             ClusterIP   10.100.25.239    &lt;none&gt;        80/TCP,443/TCP               12m
argocd-server-metrics                     ClusterIP   10.100.46.64     &lt;none&gt;        8083/TCP                     12m
</code></pre>
<p> </p>
<p>O service que precisamos por agora do ArgoCD é o <code>argocd-server</code>, e o endereço completo é <code>argocd-server.argocd.svc.cluster.local</code>.</p>
<p>Vamos fazer o port-forward para acessar o ArgoCD sem precisar expor:</p>
<pre><code class="language-bash">kubectl port-forward svc/argocd-server -n argocd 8080:443
</code></pre>
<p> </p>
<p>Pronto, agora podemos acessar o ArgoCD através do endereço <code>localhost:8080</code>, tanto pelo navegador quanto pelo CLI.</p>
<p>Vamos continuar com a nossa saga utilizando o CLI, então vamos fazer a autenticação no ArgoCD.</p>
<p>Para fazer a autenticação no ArgoCD, precisamos executar o seguinte comando:</p>
<pre><code class="language-bash">argocd login localhost:8080
</code></pre>
<p> </p>
<p>Perceba que ele irá pedir o usuário e a senha, mas não se preocupe, pois o usuário padrão do ArgoCD é o <code>admin</code>, e a senha inicial está armazenada em um secret, então vamos executar o seguinte comando para pegar a senha:</p>
<pre><code class="language-bash">kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath=&quot;{.data.password}&quot; | base64 -d
</code></pre>
<p> </p>
<p>A saída será a sua senha inicial, copie ela para que possamos utilizar no próximo comando:</p>
<pre><code class="language-bash">argocd login localhost:8080
WARNING: server certificate had error: x509: certificate signed by unknown authority. Proceed insecurely (y/n)? y
Username: admin
Password: 
'admin:login' logged in successfully
Context 'localhost:8080' updated
</code></pre>
<p> </p>
<p>Pronto, estamos autenticados no ArgoCD. Agora vamos adicionar o nosso cluster Kubernetes ao ArgoCD.</p>
<p>Para isso, vamos ver qual o contexto do nosso cluster Kubernetes:</p>
<pre><code class="language-bash">kubectl config current-context
</code></pre>
<p> </p>
<p>A saída será algo parecido com isso:</p>
<pre><code class="language-bash">girus@eks-cluster.us-east-1.eksctl.io
</code></pre>
<p> </p>
<p>Isso no meu caso que somente estou utilizando um cluster e é um EKS, lá da AWS.</p>
<p>Agora vamos adicionar o nosso cluster ao ArgoCD:</p>
<pre><code class="language-bash">argocd cluster add O_NOME_DO_SEU_CONTEXT
</code></pre>
<p> </p>
<p>No meu caso:</p>
<pre><code class="language-bash">argocd cluster add girus@eks-cluster.us-east-1.eksctl.io
</code></pre>
<p> </p>
<p>A saída será algo parecido com isso:</p>
<pre><code class="language-bash">WARNING: This will create a service account `argocd-manager` on the cluster referenced by context `girus@eks-cluster.us-east-1.eksctl.io` with full cluster level privileges. Do you want to continue [y/N]? y
INFO[0005] ServiceAccount &quot;argocd-manager&quot; created in namespace &quot;kube-system&quot; 
INFO[0005] ClusterRole &quot;argocd-manager-role&quot; created    
INFO[0005] ClusterRoleBinding &quot;argocd-manager-role-binding&quot; created 
Cluster 'https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com' added
</code></pre>
<p> </p>
<p>Caso esteja utilizando um cluster k8s no mesmo host em que está executando o kubectl, como é o que acontece quando usamos um cluster via kind ou minikube por exemplo, você pode ter o seguinte erro:</p>
<pre><code class="language-bash">WARNING: This will create a service account `argocd-manager` on the cluster referenced by context `kind-kind` with full cluster level privileges. Do you want to continue [y/N]? y
INFO[0020] ServiceAccount &quot;argocd-manager&quot; created in namespace &quot;kube-system&quot; 
INFO[0020] ClusterRole &quot;argocd-manager-role&quot; created    
INFO[0020] ClusterRoleBinding &quot;argocd-manager-role-binding&quot; created 
INFO[0025] Created bearer token secret for ServiceAccount &quot;argocd-manager&quot; 
FATA[0025] rpc error: code = Unknown desc = Get &quot;https://127.0.0.1:32919/version?timeout=32s&quot;: dial tcp 127.0.0.1:32919: connect: connection refused
</code></pre>
<p>Para contornar esse erro execute o comando <code>kubectl get -n default endpoints</code>. A saída será algo parecido com isso:</p>
<pre><code class="language-bash">NAME         ENDPOINTS         AGE
kubernetes   172.18.0.2:6443   103m
</code></pre>
<p>Agora copie o ip e porta que foi mostrado com a execução do comando anterior e altere somente o valor de endereço do server no seu arquivo <code>.kube/config</code>, como no exemplo abaixo onde o ip antigo foi comentado e o novo endereço foi configurado:</p>
<pre><code class="language-yaml">apiVersion: v1
clusters:
- cluster:
    #server: https://127.0.0.1:32919
    server: https://172.18.0.2:6443
  name: kind-kind

</code></pre>
<p>Após essa modificação execute novamente o comando para adicionar o cluster ao ArgoCD</p>
<pre><code class="language-bash">argocd cluster add O_NOME_DO_SEU_CONTEXT
</code></pre>
<p>E desta vez a saída sem erro será parecida com isso:</p>
<pre><code class="language-bash">WARNING: This will create a service account `argocd-manager` on the cluster referenced by context `kind-kind` with full cluster level privileges. Do you want to continue [y/N]? y
INFO[0001] ServiceAccount &quot;argocd-manager&quot; already exists in namespace &quot;kube-system&quot; 
INFO[0001] ClusterRole &quot;argocd-manager-role&quot; updated    
INFO[0001] ClusterRoleBinding &quot;argocd-manager-role-binding&quot; updated 
Cluster 'https://172.18.0.2:6443' added
</code></pre>
<p> </p>
<p>Pronto, nosso cluster foi adicionado ao ArgoCD.</p>
<p>Vamos confirmar se o nosso cluster foi adicionado ao ArgoCD:</p>
<pre><code class="language-bash">argocd cluster list
</code></pre>
<p>A saída será algo parecido com isso:</p>
<pre><code class="language-bash">SERVER                                                                    NAME                                   VERSION  STATUS   MESSAGE                                                  PROJECT
https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com  girus@eks-cluster.us-east-1.eksctl.io           Unknown  Cluster has no applications and is not being monitored.  
https://kubernetes.default.svc                                            in-cluster                                      Unknown  Cluster has no applications and is not being monitored. 
</code></pre>
<p> </p>
<p>Na saída, temos o nosso cluster adicionado, e o cluster local, que é o <code>in-cluster</code>, que vem por padrão.</p>
<p> </p>
<p>Pronto, já temos onde a nossa aplicação vai ser implantada, agora vamos criar a nossa aplicação para o ArgoCD.</p>
<p> </p>
<h2 id="criando-a-aplicação-no-argocd"><a class="header" href="#criando-a-aplicação-no-argocd">Criando a aplicação no ArgoCD</a></h2>
<p>Agora que já temos o nosso cluster adicionado ao ArgoCD, vamos criar a nossa aplicação. Para isso, temos que ter um repositório Git com o nosso código, e o ArgoCD vai monitorar esse repositório e vai fazer o deploy da nossa aplicação sempre que tiver uma alteração.</p>
<h3 id="criando-a-nossa-app-exemplo"><a class="header" href="#criando-a-nossa-app-exemplo">Criando a nossa app exemplo</a></h3>
<p>Para o nosso exemplo, vamos utilizar um repo que criem no GitHub, e o código está disponível <a href="https://github.com/badtuxx/k8s-deploy-nginx-example">aqui</a>. </p>
<p>Eu criei esse repo somente para servir de exemplo para essa nossa primeira parte. O que temos nesse repo são somente quatro arquivos, um que define o nosso <code>Deployment</code>, outro que define o nosso <code>Service</code>, temos um que define um <code>ConfigMap</code> e outro que define um <code>Pod</code>.</p>
<p>O nosso <code>Deployment</code> é bem simples, ele cria um <code>Pod</code> com dois containers, um que é o <code>nginx</code> e outro que é o <code>nginx-exporter</code>, que é um container que vai expor as métricas do nginx para o Prometheus.</p>
<p>O nosso <code>Service</code> é bem simples também, ele expõe a porta <code>9113</code> do nosso <code>Pod</code>, que é a porta que o <code>nginx-exporter</code>.</p>
<p>Já o nosso <code>ConfigMap</code> é um <code>ConfigMap</code> que terá a configuração default do nginx, que é o <code>default.conf</code>.</p>
<p>Os arquivos são esses:</p>
<ul>
<li>nginx-deployment.yaml</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1 # versão da API
kind: Deployment # tipo de recurso, no caso, um Deployment
metadata: # metadados do recurso 
  name: nginx-server # nome do recurso
spec: # especificação do recurso
  selector: # seletor para identificar os pods que serão gerenciados pelo deployment
    matchLabels: # labels que identificam os pods que serão gerenciados pelo deployment
      app: nginx # label que identifica o app que será gerenciado pelo deployment
  replicas: 2 # quantidade de réplicas do deployment
  template: # template do deployment
    metadata: # metadados do template
      labels: # labels do template
        app: nginx # label que identifica o app
      annotations: # annotations do template
        prometheus.io/scrape: 'true' # habilita o scraping do Prometheus
        prometheus.io/port: '9113' # porta do target
    spec: # especificação do template
      containers: # containers do template 
        - name: nginx # nome do container
          image: nginx # imagem do container do Nginx
          ports: # portas do container
            - containerPort: 80 # porta do container
              name: http # nome da porta
          volumeMounts: # volumes que serão montados no container
            - name: nginx-config # nome do volume
              mountPath: /etc/nginx/conf.d/default.conf # caminho de montagem do volume
              subPath: nginx.conf # subpath do volume
        - name: nginx-exporter # nome do container que será o exporter
          image: 'nginx/nginx-prometheus-exporter:0.11.0' # imagem do container do exporter
          args: # argumentos do container
            - '-nginx.scrape-uri=http://localhost/metrics' # argumento para definir a URI de scraping
          resources: # recursos do container
            limits: # limites de recursos
              memory: 128Mi # limite de memória
              cpu: 0.3 # limite de CPU
          ports: # portas do container
            - containerPort: 9113 # porta do container que será exposta
              name: metrics # nome da porta
      volumes: # volumes do template
        - configMap: # configmap do volume, nós iremos criar esse volume através de um configmap
            defaultMode: 420 # modo padrão do volume
            name: nginx-config # nome do configmap
          name: nginx-config # nome do volume
</code></pre>
<p> </p>
<ul>
<li>nginx-service.yaml</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1 # versão da API
kind: Service # tipo de recurso, no caso, um Service
metadata: # metadados do recurso
  name: nginx-svc # nome do recurso
  labels: # labels do recurso
    app: nginx # label para identificar o svc
spec: # especificação do recurso
  ports: # definição da porta do svc 
  - port: 9113 # porta do svc
    name: metrics # nome da porta
  selector: # seletor para identificar os pods/deployment que esse svc irá expor
    app: nginx # label que identifica o pod/deployment que será exposto
</code></pre>
<p> </p>
<ul>
<li>nginx-configmap.yaml</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1 # versão da API
kind: ConfigMap # tipo de recurso, no caso, um ConfigMap
metadata: # metadados do recurso
  name: nginx-config # nome do recurso
data: # dados do recurso
  nginx.conf: | # inicio da definição do arquivo de configuração do Nginx
    server {
      listen 80;
      location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
      }
      location /metrics {
        stub_status on;
        access_log off;
      }
    }
</code></pre>
<p> </p>
<ul>
<li>nginx-pod.yaml</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers: # containers do template 
    - name: nginx-container # nome do container
      image: nginx # imagem do container do Nginx
      ports: # portas do container
        - containerPort: 80 # porta do container
          name: http # nome da porta
      volumeMounts: # volumes que serão montados no container
        - name: nginx-config # nome do volume
          mountPath: /etc/nginx/conf.d/default.conf # caminho de montagem do volume
          subPath: nginx.conf # subpath do volume
    - name: nginx-exporter # nome do container que será o exporter
      image: 'nginx/nginx-prometheus-exporter:0.11.0' # imagem do container do exporter
      args: # argumentos do container
        - '-nginx.scrape-uri=http://localhost/metrics' # argumento para definir a URI de scraping
      resources: # recursos do container
        limits: # limites de recursos
          memory: 128Mi # limite de memória
          cpu: 0.3 # limite de CPU
      ports: # portas do container
        - containerPort: 9113 # porta do container que será exposta
          name: metrics # nome da porta
  volumes: # volumes do template
    - configMap: # configmap do volume, nós iremos criar esse volume através de um configmap
        defaultMode: 420 # modo padrão do volume
        name: nginx-config # nome do configmap
      name: nginx-config # nome do volume
</code></pre>
<p> </p>
<p>Pronto, explicado o que temos nesse repo. Basicamente quatro manifestos que irão criar um <code>Deployment</code> com dois <code>Pods</code>, um <code>Service</code>, um <code>ConfigMap</code>, além de um <code>Pod</code>solto.</p>
<p>A mágica que queremos aqui é fazer com que o ArgoCD faça o deploy do nosso <code>Deployment</code> e <code>Service</code> e tudo mais que está no nosso repo, mas para isso precisamos criar um <code>Application</code> que irá fazer o deploy do nosso <code>Deployment</code> e <code>Service</code>.</p>
<h3 id="criando-a-app-no-argocd-usando-o-argocd-cli"><a class="header" href="#criando-a-app-no-argocd-usando-o-argocd-cli">Criando a app no ArgoCD usando o ArgoCD CLI</a></h3>
<p>Já sabemos o que queremos ter em nosso cluster, agora bora criar a nossa aplicação no ArgoCD com o seguinte comando:</p>
<pre><code class="language-bash">argocd app create nginx-app --repo https://github.com/badtuxx/k8s-deploy-nginx-example.git --path . --dest-server https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com --dest-namespace default
</code></pre>
<p> </p>
<p>Onde:</p>
<ul>
<li><code>nginx-app</code> é o nome da nossa aplicação</li>
<li><code>repo</code> é o repo onde está o nosso código</li>
<li><code>path</code> é o caminho onde está o nosso código</li>
<li><code>dest-server</code> é o cluster onde queremos fazer o deploy</li>
<li><code>dest-namespace</code> é o namespace onde queremos fazer o deploy</li>
</ul>
<p>A saída do comando será algo como:</p>
<pre><code class="language-bash">Application 'nginx-app' created
</code></pre>
<p> </p>
<h3 id="primeiros-passos-com-o-argocd-e-nossa-app"><a class="header" href="#primeiros-passos-com-o-argocd-e-nossa-app">Primeiros passos com o ArgoCD e nossa app</a></h3>
<p>Agora vamos ver se o nosso <code>Application</code> foi criado com sucesso:</p>
<pre><code class="language-bash">argocd app list
</code></pre>
<p> </p>
<p>A saída do comando será algo como:</p>
<pre><code class="language-bash">NAME     CLUSTER                                                                   NAMESPACE  PROJECT  STATUS     HEALTH   SYNCPOLICY  CONDITIONS  REPO                                                     PATH  TARGET
argocd/nginx-app  https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com  default    default  OutOfSync  Missing  &lt;none&gt;      &lt;none&gt;      https://github.com/badtuxx/k8s-deploy-nginx-example.git  . 
</code></pre>
<p> </p>
<p>Agora vamos ver o que está acontecendo com o nosso <code>Application</code>:</p>
<pre><code class="language-bash">argocd app get nginx-app
</code></pre>
<p> </p>
<p>Ele irá retornar algo como:</p>
<pre><code class="language-bash">Name:               argocd/nginx-app
Project:            default
Server:             https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com
Namespace:          default
URL:                https://localhost:8080/applications/nginx-app
Repo:               https://github.com/badtuxx/k8s-deploy-nginx-example.git
Target:             
Path:               .
SyncWindow:         Sync Allowed
Sync Policy:        &lt;none&gt;
Sync Status:        OutOfSync from  (18397fa)
Health Status:      Missing

GROUP  KIND        NAMESPACE  NAME          STATUS     HEALTH   HOOK  MESSAGE
       ConfigMap   default    nginx-config  OutOfSync  Missing        
       Pod         default    nginx-pod     OutOfSync  Missing        
       Service     default    nginx-svc     OutOfSync  Missing        
apps   Deployment  default    nginx-server  OutOfSync  Missing        
</code></pre>
<p> </p>
<p>Duas informações importantes aqui:</p>
<ul>
<li>O <code>Application</code> está com o status <code>OutOfSync</code> e o <code>Sync Status</code> também está <code>OutOfSync</code>;</li>
<li>O <code>Application</code> está com o status <code>Missing</code> e o <code>Health Status</code> também está <code>Missing</code>.</li>
</ul>
<p> </p>
<p>Precisa de mais alguma informação? Vamos ver o que o ArgoCD está tentando fazer:</p>
<pre><code class="language-bash">argocd app logs nginx-app
</code></pre>
<p> </p>
<p>Ainda não temos nada, pois o ArgoCD ainda não fez nada, pois o nosso <code>Application</code> está com o status <code>OutOfSync</code> e o <code>Sync Status</code> também está <code>OutOfSync</code>, então precisamos fazer o sync do nosso <code>Application</code> para que o ArgoCD possa fazer o deploy do nosso <code>Deployment</code> e <code>Service</code>:</p>
<pre><code class="language-bash">argocd app sync nginx-app
</code></pre>
<p> </p>
<p>A saída do comando será algo como:</p>
<pre><code class="language-bash">TIMESTAMP                  GROUP        KIND   NAMESPACE                  NAME    STATUS    HEALTH        HOOK  MESSAGE
2023-03-05T19:04:16+01:00          ConfigMap     default          nginx-config  OutOfSync  Missing              
2023-03-05T19:04:16+01:00                Pod     default             nginx-pod  OutOfSync  Missing              
2023-03-05T19:04:16+01:00            Service     default             nginx-svc  OutOfSync  Missing              
2023-03-05T19:04:16+01:00   apps  Deployment     default          nginx-server  OutOfSync  Missing              
2023-03-05T19:04:17+01:00          ConfigMap     default          nginx-config    Synced  Missing              
2023-03-05T19:04:17+01:00            Service     default             nginx-svc    Synced  Healthy              
2023-03-05T19:04:17+01:00          ConfigMap     default          nginx-config    Synced   Missing              configmap/nginx-config created
2023-03-05T19:04:17+01:00            Service     default             nginx-svc    Synced   Healthy              service/nginx-svc created
2023-03-05T19:04:17+01:00                Pod     default             nginx-pod  OutOfSync  Missing              pod/nginx-pod created
2023-03-05T19:04:17+01:00   apps  Deployment     default          nginx-server  OutOfSync  Missing              deployment.apps/nginx-server created
2023-03-05T19:04:17+01:00                Pod     default             nginx-pod    Synced  Progressing              pod/nginx-pod created
2023-03-05T19:04:17+01:00   apps  Deployment     default          nginx-server    Synced  Progressing              deployment.apps/nginx-server created

Name:               argocd/nginx-app
Project:            default
Server:             https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com
Namespace:          default
URL:                https://localhost:8080/applications/nginx-app
Repo:               https://github.com/badtuxx/k8s-deploy-nginx-example.git
Target:             
Path:               .
SyncWindow:         Sync Allowed
Sync Policy:        &lt;none&gt;
Sync Status:        Synced to  (18397fa)
Health Status:      Progressing

Operation:          Sync
Sync Revision:      18397faeb8c9f6a10a63d3091d8021655778db7c
Phase:              Succeeded
Start:              2023-03-05 19:04:15 +0100 CET
Finished:           2023-03-05 19:04:17 +0100 CET
Duration:           2s
Message:            successfully synced (all tasks run)

GROUP  KIND        NAMESPACE  NAME          STATUS  HEALTH       HOOK  MESSAGE
       ConfigMap   default    nginx-config  Synced                     configmap/nginx-config created
       Service     default    nginx-svc     Synced  Healthy            service/nginx-svc created
       Pod         default    nginx-pod     Synced  Progressing        pod/nginx-pod created
apps   Deployment  default    nginx-server  Synced  Progressing        deployment.apps/nginx-server created
</code></pre>
<p> </p>
<p>Preste atenção nessa parte aqui:</p>
<pre><code class="language-bash">GROUP  KIND        NAMESPACE  NAME          STATUS  HEALTH       HOOK  MESSAGE
       ConfigMap   default    nginx-config  Synced                     configmap/nginx-config created
       Service     default    nginx-svc     Synced  Healthy            service/nginx-svc created
       Pod         default    nginx-pod     Synced  Progressing        pod/nginx-pod created
apps   Deployment  default    nginx-server  Synced  Progressing        deployment.apps/nginx-server created
</code></pre>
<p> </p>
<p>Aqui ele está dizendo que o <code>ConfigMap</code> foi criado, o <code>Service</code> foi criado, o <code>Pod</code> foi criado e o <code>Deployment</code> foi criado. Parece que está tudo certo, certo? </p>
<p>Vamos ver se ele criou algo no Kubernetes:</p>
<pre><code class="language-bash">kubectl get pods
</code></pre>
<p> </p>
<p>Parece que sim hein?</p>
<pre><code class="language-bash">NAME                            READY   STATUS    RESTARTS   AGE
nginx-pod                       2/2     Running   0          2m14s
nginx-server-6949f64b59-jc7pj   2/2     Running   0          2m14s
nginx-server-6949f64b59-l42zn   2/2     Running   0          2m14s
</code></pre>
<p> </p>
<p>Agora vamos ver se o <code>Service</code> está funcionando:</p>
<pre><code class="language-bash">kubectl get svc
</code></pre>
<p> </p>
<pre><code class="language-bash">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.100.0.1       &lt;none&gt;        443/TCP    59m
nginx-svc    ClusterIP   10.100.146.231   &lt;none&gt;        9113/TCP   2m40s
</code></pre>
<p> </p>
<p>Somente falta ver se o <code>ConfigMap</code> foi criado:</p>
<pre><code class="language-bash">kubectl get cm
</code></pre>
<p> </p>
<pre><code class="language-bash">NAME               DATA   AGE
kube-root-ca.crt   1      60m
nginx-config       1      3m13s
</code></pre>
<p> </p>
<p>Pronto, tudo funcionando.</p>
<p>Bora ver novamente o status do nosso <code>Application</code>:</p>
<pre><code class="language-bash">argocd app get nginx-app
</code></pre>
<p> </p>
<pre><code class="language-bash">Name:               argocd/nginx-app
Project:            default
Server:             https://F40E37CE91565CC520A53CB1B191CCCA.gr7.us-east-1.eks.amazonaws.com
Namespace:          default
URL:                https://localhost:8080/applications/nginx-app
Repo:               https://github.com/badtuxx/k8s-deploy-nginx-example.git
Target:             
Path:               .
SyncWindow:         Sync Allowed
Sync Policy:        &lt;none&gt;
Sync Status:        Synced to  (18397fa)
Health Status:      Healthy

GROUP  KIND        NAMESPACE  NAME          STATUS  HEALTH   HOOK  MESSAGE
       ConfigMap   default    nginx-config  Synced                 configmap/nginx-config created
       Service     default    nginx-svc     Synced  Healthy        service/nginx-svc created
       Pod         default    nginx-pod     Synced  Healthy        pod/nginx-pod created
apps   Deployment  default    nginx-server  Synced  Healthy        deployment.apps/nginx-server created
</code></pre>
<p> </p>
<p>Tudo está <code>Synced</code> e <code>Healthy</code>.</p>
<p>E os logs?</p>
<pre><code class="language-bash">argocd app logs nginx-app --container nginx
</code></pre>
<p> </p>
<pre><code class="language-bash">/docker-entrypoint.sh: Configuration complete; ready for start up
2023/03/05 18:04:22 [notice] 1#1: using the &quot;epoll&quot; event method
2023/03/05 18:04:22 [notice] 1#1: nginx/1.23.3
2023/03/05 18:04:22 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)
2023/03/05 18:04:22 [notice] 1#1: OS: Linux 5.4.228-132.418.amzn2.x86_64
2023/03/05 18:04:22 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2023/03/05 18:04:22 [notice] 1#1: start worker processes
2023/03/05 18:04:22 [notice] 1#1: start worker process 21
2023/03/05 18:04:22 [notice] 1#1: start worker process 22
</code></pre>
<p> </p>
<p>O que ele faz é trazer o log do container <code>nginx</code> do pod <code>nginx-pod</code> que foi criado pelo <code>Deployment</code> <code>nginx-server</code>, mesma coisa que se você tivesse feito:</p>
<pre><code class="language-bash">kubectl logs -f nginx-pod -c nginx
</code></pre>
<p> </p>
<p>Simples demais!</p>
<p> </p>
<p>Vamos recapitular os comandos do ArgoCD:</p>
<pre><code class="language-bash">argocd login localhost:8080 # Faz o login no ArgoCD
argocd add cluster NOME_DO_SEU_CONTEXT # Adiciona um cluster ao ArgoCD
argocd app create nginx-app --repo https://github.com/badtuxx/k8s-deploy-nginx-example.git --path . --dest-server NOME_DO_SEU_CONTEXT --dest-namespace default
argocd app list # Lista os aplicativos
argocd app get nginx-app # Mostra o status do aplicativo
argocd app logs nginx-app --container nginx # Mostra os logs do aplicativo
argocd app sync nginx-app # Sincroniza o aplicativo com o repositório
</code></pre>
<p> </p>
<h2 id="final-day-1"><a class="header" href="#final-day-1">Final Day-1</a></h2>
<p>Acho que é o que precisamos para o nosso primeiro dia de trabalho com o ArgoCD. Durante o dia de hoje você aprendeu:</p>
<ul>
<li>Como instalar o ArgoCD no Kubernetes</li>
<li>Como autenticar no ArgoCD</li>
<li>Como adicionar um cluster ao ArgoCD</li>
<li>Os detalhes de como criar um deployment, service e configmap no Kubernetes</li>
<li>Como criar um aplicativo no ArgoCD</li>
<li>Como sincronizar um aplicativo no ArgoCD</li>
<li>Como ver o status de um aplicativo no ArgoCD</li>
<li>Como ver os logs de um aplicativo no ArgoCD</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../BOOKSUMMARY.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../BOOKSUMMARY.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>